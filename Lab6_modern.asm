[org 0x7c00] ; Початок BOOT сектора
[bits 16]
; ЛР  №6
;------------------------------------------------------------------------------
; Архітектура комп'ютера
; ВУЗ:          КНУУ "КПІ"
; Факультет:    ФІОТ
; Курс:         1
; Група:        ІТ-03
;------------------------------------------------------------------------------
; Автори:       Філянін Чабан Хамад
; Команда:      №6
; Дата:         25/04/2021

;------------------ПОЧАТОК СЕГМЕНТУ КОДУ-------------------------------------------
Start:
mov di, 0x56   					; di <- номер нового переривання (50 + номер бригади)
call getVector					; виклик процедури
mov [v_offset], bx 				; в змінну зміщення старої функції обробки 
mov [v_seg], es 				; в змінну сегмент старої функції обробки

; Значення для процедури
mov di, 0x56
mov dx, int56
mov ax, 0
mov es, ax

call setVector					; виклик процедури

int 0x56						; викликаємо наше переривання

; Значення для процедури повернення обробника
mov di, 0x56
mov dx, [v_offset]
mov ax, [v_seg]
mov es, ax

call setVector					; виклик процедури

xor al,al						; зачищаємо al

jmp $ 							; завершення

; Призначення: збереження даних функції обробки переривання	
; Вхід: di - номер вектора переривання
; Вихід: bx, es - зміщення та сегмент функції переривання
getVector:
; Зберігаємо дані регістрів в стеку
	push ax
	push di
	xor ax,ax 					; в ax 0
	mov es,ax 					; в es 0
	shl di, 2					; DI*4 (зв'язок номера переривання і адреси)
	mov bx, [es:di] 			; bx <- зміщення процедури у векторі переривань
	mov ax, [es:di+2] 		; es <- сегмент процедури у векторі переривань
	mov es, ax
	
;Повертаємо дані зі стеку
	pop di
	pop ax
	ret ; повертаємось з процедури

; Призначення: встановлення на номер вектора переривань нового значення	
; Функціонально: до пам’яті, що відповідає вектору заносимо ефективну адресу і адресу 
; сегменту нового обробника переривань
; Вхід: di - номер вектора переривання, dx - адреса нового обробника, es - адреса сегмента нового обробника
; Вихід: -
setVector:

; Зберігаємо дані регістрів в стеку
	push ax 
	push di
	push ds
	xor ax, ax 					; в ax 0
	mov ds, ax 					; в ds 0, переходимо до адреси 0000h
	shl di, 2 					; DI*4
	mov [ds:di], dx 			; Перезаписуємо зміщення у векторі переривань 
	mov [ds:di+2], es			; Перезаписуємо адресу сегмента у векторі переривань
; Повертаємо дані зі стеку
	pop ds
	pop di
	pop ax
	ret ; Не забуваємо повернутися з процедури (функції)


; Призначення: виводить в консоль фамілії
; Вхід: -
; Вихід: -
int56:

	mov si, mess 				; рядок для виводу
	call printf

; Код для закінчення переривання
	mov al, 0x20
	out 0x20, al
	iret 						; вихід з процедури	

printf:  
       pusha  

	; Записуємо в AL поточний символ по зміщенню SI
       print_loop:
               mov al, [si]
               cmp al, 0
               jne print_char ; Якщо це ще не кінець рядка
               popa
               ret

       print_char:
               mov ah, 0x0e
               int 0x10 ; Друкуємо символ, що знаходиться в AL
               add si, 1 ; Переходимо до наступного символа в рядку
               jmp print_loop

v_offset dw 0 			; Змінна для зміщення
v_seg dw 0 				; Змінна для сегементу
mess db "Group 6:",10,13, "Filianin",10,13, "Chaban",10,13, "Hamad",10,13,0
exCode db 0				; Код виходу

times 510-($-$$) db 0
dw 0xAA55